# 代码实现 (Coding Implementer) - 详细工作流程

代码实现阶段负责将建模方案转化为高质量的代码实现。

> **注意**: 这是第三层参考文档。核心使用方法请参见 `SKILL.md`。

---

## 核心职责

1. **代码编写**: 根据建模分析文档编写完整的代码
2. **语言支持**: 支持 Python 和 MATLAB 两种编程语言
3. **结果输出**: 确保结果输出到文件和终端
4. **数据可视化**: 生成精美的SCI/Nature风格图表
5. **文档说明**: 撰写README.md说明文档

---

## 算法资源库（代码实现参考）

本技能提供完整的算法说明文档，位于 `assets/` 目录下，包含代码实现要点和可视化图表类型建议。

### 快速索引

| 算法类别 | 文档 | 代码实现参考 |
|---------|------|-------------|
| **优化算法** | `assets/01-优化算法说明.md` | scipy.optimize.linprog, pulp, cvxpy, DEAP, pyswarms 等 |
| **预测算法** | `assets/02-预测类算法说明.md` | statsmodels, scikit-learn, tensorflow, Prophet 等 |
| **评价算法** | `assets/03-评价类算法说明.md` | 自定义实现 AHP、熵权法、TOPSIS、灰色关联分析等 |
| **图论网络** | `assets/04-图论与网络分析算法说明.md` | networkx, scipy.sparse.csgraph 等 |
| **统计分析** | `assets/05-统计分析与数据处理算法说明.md` | scikit-learn, scipy.stats, factor_analyzer 等 |
| **综合算法** | `assets/06-综合类算法说明.md` | numpy.random, networkx, matplotlib.animation 等 |
| **机器学习** | `assets/07-机器学习算法说明.md` | scikit-learn (RandomForestClassifier, AdaBoostClassifier, IsolationForest) 等 |

### 使用建议

1. **查找代码实现**：查看算法文档中的"代码实现要点"部分，获取函数调用示例
2. **确定可视化类型**：参考算法文档中的"可视化图表类型"，选择合适的图表
3. **参数设置**：参考算法文档中的算法参数说明，合理设置参数
4. **Python库选择**：参考算法文档中推荐的Python库和函数

### 常用库速查

| 功能 | Python库 | MATLAB对应 |
|-----|---------|-----------|
| 线性规划 | scipy.optimize.linprog, pulp | linprog |
| 整数规划 | pulp, ortools | intlinprog |
| 聚类 | sklearn.cluster | kmeans, linkage |
| 回归 | sklearn.linear_model | regress, fitlm |
| 时间序列 | statsmodels, Prophet | arima, econometric |
| 神经网络 | tensorflow, keras | nntoolbox |
| 图论 | networkx | graph, digraph |
| 可视化 | matplotlib, seaborn | plot, subplot |

---

## 工作流程

### 第一步：理解需求

1. **读取建模分析文档**: 理解建模手的分析结果
2. **确认编程语言**: Python 或 MATLAB（如果未指定，询问用户）
3. **理解题目要求**: 读取题目文件，明确需要解决的问题

### 第二步：代码设计

根据建模方案设计代码结构：

1. **模块划分**: 将代码划分为清晰的功能模块
2. **数据结构**: 设计合理的数据结构和变量命名
3. **算法实现**: 确定具体的算法实现方法
4. **可视化规划**: 规划需要绘制的图表类型和数量

### 第三步：代码实现

编写高质量的代码，遵循以下要求：

### 第四步：结果验证

**每道题代码运行后必须进行结果验证**：

1. **确保结果输出**：每道题的代码运行后必须有合理的结果输出
   - 输出到 `.csv` 文件：表格形式的数据结果
   - 输出到 `.txt` 文件：详细的计算过程和结果说明
   - 输出到终端：关键结果的打印显示

2. **判断结果正确性**：
   - 结合题目要求：检查结果是否满足题目中的约束条件和目标
   - 结合建模分析文档：验证结果是否符合建模手的预期
   - 结合运行效果：检查可视化图表是否合理、数据是否异常

**验证检查清单**：

| 检查项 | 说明 |
|-------|------|
| 结果完整性 | 所有要求的输出项都已生成 |
| 结果合理性 | 数值范围、符号、量级是否符合预期 |
| 约束满足 | 是否满足题目中的约束条件 |
| 图表验证 | 可视化结果是否直观、合理 |

### 第五步：迭代改进

**如果结果不正确，必须先改进代码再进行下一个问题**：

```
┌────────────────────────────────────────────────────────────┐
│  编程手问题解决流程                                        │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  问题1: 编写代码 → 运行 → 结果验证                          │
│      ├─ 结果正确 → 继续问题2                               │
│      └─ 结果错误 → 改进代码 → 重新运行 → 重新验证           │
│                                                            │
│  问题2: 编写代码 → 运行 → 结果验证                          │
│      ├─ 结果正确 → 继续问题3                               │
│      └─ 结果错误 → 改进代码 → 重新运行 → 重新验证           │
│                                                            │
│  ... 以此类推，直到所有问题都正确解决                       │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

**迭代改进原则**：

| 原则 | 说明 |
|------|------|
| **问题隔离** | 每次只解决一个问题，确保当前问题正确后再进入下一个 |
| **代码调试** | 检查算法实现、参数设置、数据处理逻辑 |
| **结果对比** | 对比改进前后的结果，分析变化原因 |
| **文档记录** | 记录每次改进的内容和原因 |

---

## 代码要求

### 0. 核心原则（必须严格遵守）

**⚠️ 编程语言确认（第一条，必须最先执行）**：
- **在编写任何代码之前，必须先向用户确认使用的编程语言**
- 如果用户未指定，必须主动询问：Python 或 MATLAB
- **禁止**在未确认编程语言的情况下直接开始编写代码
- 只有在明确用户指定的编程语言后，才能开始代码编写

**遵循建模手的设计**：
- **严格按照建模手的思路**：必须完全按照建模手在分析文档中设计的思路进行代码编写
- **严格使用指定的模型和算法**：必须使用建模手选择的数学模型和算法，不得自行更换
- **保持一致性**：代码实现应与建模分析文档保持完全一致

**超时处理原则**：
- 当代码运行超时时，**加长等待时间**，不要重新写简化的代码
- 超时通常是由于计算复杂度或数据量大导致的正常现象
- 可以通过调整超时参数、使用更高效的实现方式、增加计算资源等方式处理
- 保持算法和模型的完整性，不要为了速度而简化算法

### 1. 标准文件结构（必须严格遵守）

编程手必须按照以下标准文件结构创建和组织项目文件：

```
project/                          # 项目根目录
├── data/                         # 数据文件夹
│   ├── 问题1_data.csv            # 问题1的输入数据（题目提供，只读）
│   ├── 问题2_data.xlsx           # 问题2的输入数据（题目提供，只读）
│   └── ...                       # 其他输入数据文件
│
├── 问题1_求解.py                 # 问题1的求解代码（Python）或 问题1_求解.m（MATLAB）
├── 问题2_求解.py                 # 问题2的求解代码（Python）或 问题2_求解.m（MATLAB）
├── 问题3_求解.py                 # 问题3的求解代码（Python）或 问题3_求解.m（MATLAB）
└── ...                           # 其他问题的求解代码
│
├── results/                      # 结果输出文件夹
│   ├── results.csv               # 汇总的计算结果（CSV格式）
│   ├── results.txt               # 详细的计算结果（TXT格式）
│   ├── 问题1_results.csv         # 问题1的单独结果
│   ├── 问题2_results.csv         # 问题2的单独结果
│   └── ...                       # 其他结果文件
│
├── figures/                      # 可视化图表文件夹
│   ├── figure1.png               # 问题1的结果图（SCI/Nature风格）
│   ├── figure2.png               # 问题2的结果图（SCI/Nature风格）
│   ├── figure3.png               # 其他结果图（SCI/Nature风格）
│   └── ...                       # 其他图表文件
│
├── 建模手分析文档.md             # 建模手产出的分析文档（只读）
├── 术语表格.md                   # 建模手产出的术语表（只读）
│
└── README.md                     # 项目说明文档（必须创建）
```

**文件结构规范说明**：

| 目录/文件 | 说明 | 约束 |
|----------|------|------|
| `data/` | 存放题目提供的输入数据 | 只读，禁止修改 |
| `问题X_求解.py/.m` | 各问题的求解代码 | 每题一个文件，分开编写 |
| `results/` | 存放计算结果 | 必须输出.csv和.txt |
| `figures/` | 存放可视化图表 | SCI/Nature风格，dpi=300 |
| `README.md` | 项目说明文档 | 必须创建 |
| `建模手分析文档.md` | 建模手的分析 | 只读参考 |
| `术语表格.md` | 建模手的术语表 | 只读参考 |

**重要原则**：

1. **目录必须创建**：`data/`、`results/`、`figures/` 三个目录必须存在
2. **文件命名规范**：使用 `问题X_求解.py` 格式，X为题号
3. **结果输出完整**：每个问题都必须有对应的代码、结果和图表
4. **只读文件不修改**：`data/` 目录下的文件和建模手的文档只读不写

### 2. 代码结构清晰

**Python 示例结构**:
```python
# main.py - 主程序

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
# ... 其他必要的库

# 数据加载
def load_data(filename):
    """加载数据"""
    pass

# 数据预处理
def preprocess_data(data):
    """数据预处理"""
    pass

# 模型求解
def solve_model(data):
    """模型求解主函数"""
    pass

# 可视化
def plot_results(results):
    """结果可视化"""
    pass

# 主函数
def main():
    # 加载数据
    # 预处理
    # 求解
    # 可视化
    # 输出结果
    pass

if __name__ == "__main__":
    main()
```

**MATLAB 示例结构**:
```matlab
% main.m - 主程序

% 清空环境
clear; clc; close all;

% 加载数据
% 预处理数据
% 模型求解
% 结果可视化
% 输出结果
```

### 2. 添加注释

- 关键算法步骤添加注释
- 重要参数说明
- 复杂逻辑解释
- 函数功能说明

### 3. 结果输出

确保结果输出到：

| 输出类型 | 格式 | 说明 |
|---------|------|------|
| 终端输出 | 控制台打印 | 关键结果打印 |
| CSV文件 | .csv | 表格数据 |
| TXT文件 | .txt | 详细结果 |

```python
# 结果输出示例
print(f"最优解: {solution}")
print(f"目标函数值: {objective_value}")

results_df = pd.DataFrame(results)
results_df.to_csv('results.csv', index=False)

with open('results.txt', 'w') as f:
    f.write(f"最优解: {solution}\n")
    f.write(f"目标函数值: {objective_value}\n")
```

### 4. 数据可视化

生成精美的图表，使用SCI/Nature风格：

**重要约束**：
- 每个大图最多包含 **2个子图**（使用 `subplots(1,2)` 或 `subplots(2,1)`）
- **禁止** 在一个大图中包含 3 个或更多子图
- 如需展示多张图表，请分成多个独立的图片文件

**可视化代码编写原则**：
- **集成式可视化**：可视化代码应与解决问题的主代码一起编写，嵌入在数据处理的合适位置，运行时可以实时获取数据和画图，而不是在运行完成后再单独画图
- **3D图表使用**：在合适的场景下（如多维数据展示、优化过程可视化、聚类结果展示等）使用3D图表以增强视觉效果

**Python可视化配置**:
```python
import matplotlib.pyplot as plt

# 设置SCI/Nature风格
plt.rcParams['font.sans-serif'] = ['Arial']
plt.rcParams['font.size'] = 10
plt.rcParams['axes.linewidth'] = 1.5
plt.rcParams['xtick.major.width'] = 1.5
plt.rcParams['ytick.major.width'] = 1.5
plt.rcParams['lines.linewidth'] = 2

# 单图示例
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(x, y, 'b-', linewidth=2, label='Data')
ax.set_xlabel('X Label', fontsize=12)
ax.set_ylabel('Y Label', fontsize=12)
ax.legend(fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.savefig('figure1.png', dpi=300, bbox_inches='tight')
plt.show()

# 两子图示例（正确：最多2个子图）
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
ax1.plot(x1, y1, 'r-', linewidth=2)
ax1.set_xlabel('X1', fontsize=12)
ax1.set_ylabel('Y1', fontsize=12)
ax1.grid(True, linestyle='--', alpha=0.6)

ax2.plot(x2, y2, 'b-', linewidth=2)
ax2.set_xlabel('X2', fontsize=12)
ax2.set_ylabel('Y2', fontsize=12)
ax2.grid(True, linestyle='--', alpha=0.6)

plt.tight_layout()
plt.savefig('figure2.png', dpi=300, bbox_inches='tight')
plt.show()

# 3D图示例（适用于多维数据展示、聚类结果等场景）
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x, y, z, c=labels, cmap='viridis', s=50, alpha=0.6)
ax.set_xlabel('X Label', fontsize=12)
ax.set_ylabel('Y Label', fontsize=12)
ax.set_zlabel('Z Label', fontsize=12)
ax.set_title('3D Visualization', fontsize=14, pad=20)
plt.tight_layout()
plt.savefig('figure3d.png', dpi=300, bbox_inches='tight')
plt.show()
```

**MATLAB可视化配置**:
```matlab
% 设置SCI/Nature风格
set(0,'DefaultAxesFontSize',10);
set(0,'DefaultAxesLineWidth',1.5);
set(0,'DefaultLineLineWidth',2);

% 单图示例
figure('Position',[100,100,800,600]);
plot(x,y,'b-','LineWidth',2);
xlabel('X Label','FontSize',12);
ylabel('Y Label','FontSize',12);
legend('Data','FontSize',10);
grid on;
set(gca,'LineWidth',1.5);
saveas(gcf,'figure1.png');

% 两子图示例（正确：最多2个子图）
figure('Position',[100,100,1200,500]);
subplot(1,2,1);
plot(x1,y1,'r-','LineWidth',2);
xlabel('X1','FontSize',12);
ylabel('Y1','FontSize',12);
grid on;

subplot(1,2,2);
plot(x2,y2,'b-','LineWidth',2);
xlabel('X2','FontSize',12);
ylabel('Y2','FontSize',12);
grid on;

saveas(gcf,'figure2.png');

% 3D图示例（适用于多维数据展示、聚类结果等场景）
figure('Position',[100,100,800,600]);
scatter3(x,y,z,50,labels,'filled');
xlabel('X Label','FontSize',12);
ylabel('Y Label','FontSize',12);
zlabel('Z Label','FontSize',12);
title('3D Visualization','FontSize',14);
grid on;
set(gca,'LineWidth',1.5);
saveas(gcf,'figure3d.png');
```

### 5. README.md 文档

编写详细的README.md：

```markdown
# 数学建模项目说明

## 项目概述
[项目简介]

## 使用的数学模型
[列出使用的所有数学模型]

## 建模流程
1. [步骤1]
2. [步骤2]
3. [步骤3]

## 运行说明
### 环境要求
- Python 3.x
- numpy
- pandas
- matplotlib
- scipy
- sklearn

### 运行方法
```bash
python main.py
```

## 结果说明
### 主要结果
[结果表格]

### 结果分析
[对结果的简要分析]

## 文件说明

| 文件/目录 | 说明 |
|----------|------|
| `main.py` 或 `问题1_求解.py` 等 | 主程序文件 |
| `data/` | 数据文件目录 |
| `results/` | 结果输出目录 |
| `figures/` | 图表输出目录 |
| `README.md` | 项目说明文档 |

---

## 编程语言选择

### Python 特点

| 优点 | 说明 |
|------|------|
| 丰富的科学计算库 | numpy, pandas, scipy |
| 优秀的可视化工具 | matplotlib, seaborn |
| 机器学习支持 | scikit-learn |
| 开源免费 | 无需许可证 |

**适合场景**:
- 需要数据处理和清洗
- 复杂的可视化需求
- 机器学习算法
- 网络数据获取

### MATLAB 特点

| 优点 | 说明 |
|------|------|
| 强大的数学工具箱 | 优化、统计、信号处理 |
| 矩阵运算高效 | 原生支持矩阵运算 |
| 工程应用广泛 | 工业界常用 |
| 文档完善 | 官方文档详尽 |

**适合场景**:
- 矩阵运算密集
- 优化问题求解
- 信号处理
- 控制系统

---

## 模型实现要求

### 优化模型

| 模型类型 | Python库 | MATLAB函数 |
|---------|---------|-----------|
| 线性规划 | scipy.optimize.linprog | linprog |
| 整数规划 | scipy.optimize.milp | intlinprog |
| 非线性规划 | scipy.optimize.minimize | fmincon |
| 图论算法 | networkx | graph functions |

### 预测模型

| 模型类型 | Python库 | MATLAB工具箱 |
|---------|---------|-------------|
| 时间序列 | statsmodels | econometric toolbox |
| 回归分析 | scikit-learn | regress |
| 灰色预测 | 自定义实现 | 自定义实现 |

### 评价模型

| 模型类型 | 实现方式 |
|---------|---------|
| AHP层次分析 | 自定义实现 |
| 熵权法 | 自定义实现 |
| TOPSIS | 自定义实现 |

### 分类模型

| 模型类型 | Python库 | MATLAB函数 |
|---------|---------|-----------|
| K-means聚类 | scikit-learn | kmeans |
| 层次聚类 | scipy.cluster | linkage |

---

## 质量标准

- **代码可读**: 结构清晰，命名规范，注释完整
- **运行正确**: 确保代码能够正确运行并输出结果
- **效率合理**: 算法效率合理，计算时间适中
- **图表精美**: 可视化图表符合SCI/Nature风格
- **文档完善**: README文档内容完整、格式规范

---

## 表格文件处理规范（必须严格遵守）

### 原则概述

题目中的表格文件分为两类，处理方式完全不同：

| 表格类型 | 处理原则 | 说明 |
|---------|---------|------|
| **题目附带的输入表格** | **只读不写** | 包含原始数据，只能读取和分析 |
| **结果输出表格** | **结构固定** | 只能填写数据，不能修改结构 |

### 一、题目附带输入表格（如 data.csv、附件1.xlsx）

**处理原则**：只读，绝对不能修改

```python
# 正确做法：只读取数据
import pandas as pd

# 读取题目数据
input_data = pd.read_csv('data.csv')
# 或者
input_data = pd.read_excel('附件1.xlsx')

# 处理数据...
# 计算结果...

# 输出到新文件，不修改原文件
result_data.to_csv('result.csv', index=False)

# 错误做法：修改原文件
# input_data.to_csv('data.csv', index=False)  # 禁止！
```

**支持的表格格式**：

| 格式 | 读取方法 | 写入方法 |
|------|---------|---------|
| CSV | `pd.read_csv()` | `df.to_csv()` |
| Excel (.xlsx) | `pd.read_excel()` | `df.to_excel()` |
| Excel (.xls) | `pd.read_excel()` | `df.to_excel()` |

### 二、结果输出表格（如 result.xlsx、results.csv）

**处理原则**：保持表格结构不变，只填写数据

```python
import pandas as pd
import openpyxl  # 处理Excel文件时需要

# 场景1：题目提供了空的结果模板
result_template = pd.read_excel('result_template.xlsx')

# 只能在现有结构中填写数据，不能：
# - 添加新列
# - 删除列
# - 修改列名
# - 修改列顺序

# 正确：填写数据
result_template['计算结果列'] = calculated_values
result_template.to_excel('result.xlsx', index=False)

# 错误：修改表格结构
# result_template = result_template.drop('某列', axis=1)  # 禁止！
# result_template.columns = ['新列名1', '新列名2']  # 禁止！
```

### 三、常见处理模式

**模式1：读取输入数据 → 计算结果 → 输出到新文件**

```python
import pandas as pd

# 读取输入数据（只读）
input_df = pd.read_csv('input_data.csv')

# 数据处理和计算
processed_df = process_data(input_df)
results = calculate_results(processed_df)

# 输出到新文件
results.to_csv('output_results.csv', index=False)
```

**模式2：读取输入数据 → 填写结果模板**

```python
import pandas as pd

# 读取输入数据（只读）
input_df = pd.read_excel('input.xlsx')

# 读取结果模板（保持结构）
result_template = pd.read_excel('result_template.xlsx')

# 计算并填写数据
result_template['结果列'] = calculate_results(input_df)

# 保存结果（保持原结构）
result_template.to_excel('result.xlsx', index=False)
```

**模式3：读取多个输入文件 → 合并计算 → 输出**

```python
import pandas as pd

# 读取多个输入文件（只读）
data1 = pd.read_csv('附件1.csv')
data2 = pd.read_excel('附件2.xlsx')

# 合并处理
combined_data = pd.concat([data1, data2])
results = process_combined_data(combined_data)

# 输出结果
results.to_csv('final_results.csv', index=False)
```

### 四、表格处理检查清单

- [ ] 输入表格只读不写
- [ ] 结果表格保持原有结构
- [ ] 不添加/删除列
- [ ] 不修改列名
- [ ] 不修改列顺序
- [ ] 输出到新文件，不覆盖原输入文件
- [ ] CSV 文件指定正确的编码（如 `encoding='utf-8-sig'`）
- [ ] Excel 文件指定正确的 sheet 名称或索引

---

## 注意事项

1. **⚠️ 编程语言确认（最重要，必须最先执行）**: 在编写任何代码之前，必须先向用户确认使用的编程语言（Python 或 MATLAB），禁止在未确认的情况下直接编写代码
2. **⚠️ 文件结构规范（必须严格遵守）**: 必须按照标准文件结构创建项目，包含 `data/`、`results/`、`figures/` 三个目录，代码文件命名为 `问题X_求解.py/.m` 格式
3. 代码必须完整可运行，不要只给出片段
4. 确保所有必要的库导入语句齐全
5. 测试代码确保能正常运行
6. 图表保存为高分辨率（dpi=300）
7. **子图约束**: 每个大图最多2个子图，禁止3个或更多子图
8. **表格约束**: 题目输入表格只读不写；结果表格保持结构不变
9. **结果输出要求**: 每道题代码运行后必须在.csv文件、.txt文件或终端中输出结果
10. **结果验证要求**: 必须结合题目、建模分析文档和运行效果判断结果正确性
11. **迭代改进要求**: 如果结果不正确，必须先改进代码，然后再进行下一个问题的解决，直到所有问题都正确解决为止
12. **遵循建模手设计**: 必须严格按照建模手的思路、选择的数学模型和算法进行代码编写，不得自行更换
13. **超时处理原则**: 代码运行超时时，应加长等待时间，不要重新写简化的代码
